# 3480

## Question

Given a interger `n` and a list of pairs of (distinct) integers `conflictPairs` in `{1, ..., n}`, find the maximal number of (continuous) subarray of the sequence `{1, ..., n}` that, for each pair `(a, b)` in `conflictPairs`, the subarray does not contain both `a` and `b`, if (exactly) one pair in `conflictPairs` can be removed.

## Solution

Consider first the scenario where no pair can be removed.

Starting at number `i`, where can the longest subarray end at? It is easy to see that this longest subarray must be `[i, j)` where `j` is the smallest `b` of the pair `(a, b)` where `a >= i` (or `n + 1` if there is no such pair). So, by sorting `conflictingPairs` appropriately, all such `j` can be computed in one pass.

Consider now at index `i`, the longest subarray `[i, j)` comes from the pair `(a, j)`. Obviously, if we remove this pair, we can have a longer subarray `[i, k)`, where `k` is the *second* smallest `b`, and the number of possible subarray (starting at index `i`) increases by `k - j`, where the increment comes from removing the pair `(a, j)`.

So, when computing the smallest `j` for each `i`, if we also accumulate the increment `k - j` from removing the blocking pair `(a, j)`, the maximal number is then the maximal of total increment over all `conflictingPairs` (plus the total number if no pair is removed).

As everything can be done when computing `j`, igoring the sorting part this is a linear algorithm (and may be optimal).

