# 3539

## Question

Given integers `m`, `k`, and integer array `nums` of length `n`, find the sum (module `1e9 + 7`) of weights of all valid sequence of length `m`, where
* a sequence `x[0], ..., x[m-1]` is valid if `0 <= x[i] < n`, and `sum(2 ** x[i] for i in range(m))` has exactly `k` bits set
* the weight of such sequence is `prod(nums[x[i]] for i in range(m))`

## Solution

This solution is motivated by [the hints in a submission on LC](https://leetcode.com/problems/find-sum-of-array-product-of-magical-sequences/solutions/7267991/pascal-triangle-4d-recursive-dp-11ms-beats-100).

Since the order of `x[i]` does not matter, it suffices to find all non-decreasing valid sequence `x`, then multiply its weight by $m! / \prod c_i = \prod \binom{m - \sum_{j < i} c_j}{c_i}$ with $c_i$ being the multiplicities. The second formulation allows us to append one new term at a time.

To solve the question, effectively we are filling in a sequence of `m` slots with non-decreasing numbers, by choosing the multiplicity of each entry (with multiplicity `0` being not chosen). Once we have reached the end, we check if the constructed sequence is valid, and if so accumulate the contribution of the weight.

Instead of tracking the whole state `sum(2 ** x[i] ...)` so far, we can notice that, as long as we are choosing the entries in ascending order, the newer entries cannot change the results from (distant) past. More precisely, if the current entry to consider is `i`, it cannot change the bits at index before `i`. This means that we only need to consider the last bits starting from index `i`, and on consider a new number, we can "commit" the `i`th bit and remove it from the state. With this, we only need to track `log2(m)` bits (and so `m` different states) instead of (the maximal) `m * log2(m)` bits for the whole sum (with `m * 2^m` states).

Since we are also commiting bits, we only need to store the remaining number of bits needed, without needing to recover the state to count set bits.

To implement these, we consider the dp function `dp(remainSpots, remainBits, idx, lastBits)` where
* `remainSpots` is the number of terms we still need to choose
* `remainBits` is the number of set bits we still need
* `idx` is the next entry to consider
* `lastBits` is the bits of the current sum, removing the lowest `idx` places
* and `dp(...)` represents the (modded) sum of weight contributions for filling up the remaining `remainSpots` spots with the given states

## Note

No C++ version yet. Too troublesome to write multidim dp in C++.

